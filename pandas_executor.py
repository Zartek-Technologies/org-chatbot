# pandas_executor.py
import pandas as pd
import re
from typing import Tuple, Any

class PandasCodeExecutor:
    """Safely execute pandas code generated by LLM"""
    
    def __init__(self):
        # Forbidden operations for security
        self.forbidden_keywords = [
            'import', 'eval', 'exec', 'compile', '__', 
            'open', 'file', 'os.', 'sys.', 'subprocess'
        ]
    
    def extract_code(self, llm_response: str) -> str:
        """Extract pandas expression from LLM response"""
        response_str = str(llm_response)
        

        response_str = re.sub(r'```\n?', '', response_str)
        
        # Split by lines and find the actual pandas code
        lines = response_str.strip().split('\n')
        
        # Look for lines starting with 'df' or containing pandas operations
        code_lines = []
        for line in lines:
            line = line.strip()
            if line.startswith('df') or 'df[' in line or 'df.' in line:
                code_lines.append(line)
        
        if code_lines:
            # Return the last pandas expression (usually the final result)
            return code_lines[-1]
        
        # Fallback: return the last non-empty line
        for line in reversed(lines):
            line = line.strip()
            if line and not line.startswith('#'):
                return line
        
        return response_str.strip()
    
    def validate_code(self, code: str, df: pd.DataFrame) -> Tuple[bool, str]:
        """Validate code against DataFrame schema"""
        
        # Check for forbidden keywords
        code_lower = code.lower()
        for keyword in self.forbidden_keywords:
            if keyword in code_lower:
                return False, f"Forbidden operation: {keyword}"
        
        # Extract column names referenced in the code
        # Pattern: df['column'] or df["column"]
        column_pattern = r"df\[['\"](.*?)['\"]\]|df\.(.*?)[\s\[]"
        referenced_cols = re.findall(column_pattern, code)
        
        # Flatten tuples and filter empty strings
        referenced_cols = [col for group in referenced_cols for col in group if col]
        
        # Check if all referenced columns exist
        missing_cols = [col for col in referenced_cols if col not in df.columns]
        
        if missing_cols:
            available = ', '.join(df.columns.tolist())
            return False, f"Columns not found: {missing_cols}. Available: {available}"
        
        return True, "Valid"
    
    def execute_code(self, code: str, df: pd.DataFrame) -> Tuple[bool, Any]:
        """Execute pandas code in a restricted environment"""
        
        try:
            # Create restricted namespace
            namespace = {
                'df': df,
                'pd': pd,
                # Allow common pandas/numpy functions
                'len': len,
                'str': str,
                'int': int,
                'float': float,
            }
            
            # Execute with timeout protection (using eval)
            result = eval(code, {"__builtins__": {}}, namespace)
            
            return True, result
            
        except Exception as e:
            return False, f"Execution error: {str(e)}"
    
    def format_result(self, result: Any, query: str) -> str:
        """Format execution result for business users"""
        
        # Handle different result types
        if isinstance(result, (int, float)):
            return f"**Result:** {result:,}" if isinstance(result, int) else f"**Result:** {result:.2f}"
        
        elif isinstance(result, str):
            return f"**Result:** {result}"
        
        elif isinstance(result, pd.Series):
            if len(result) == 0:
                return "No results found."
            elif len(result) <= 10:
                formatted = "\n".join([f"- {idx}: {val}" for idx, val in result.items()])
                return f"**Results:**\n\n{formatted}"
            else:
                formatted = "\n".join([f"- {idx}: {val}" for idx, val in result.head(10).items()])
                return f"**Top 10 Results:**\n\n{formatted}\n\n_(Showing 10 of {len(result)} results)_"
        
        elif isinstance(result, pd.DataFrame):
            if len(result) == 0:
                return "No results found."
            elif len(result) <= 20:
                return f"**Results ({len(result)} rows):**\n\n{result.to_markdown(index=False)}"
            else:
                return f"**Results (showing 20 of {len(result)} rows):**\n\n{result.head(20).to_markdown(index=False)}"
        
        elif isinstance(result, list):
            if len(result) == 0:
                return "No results found."
            elif len(result) <= 20:
                formatted = "\n".join([f"{i+1}. {item}" for i, item in enumerate(result)])
                return f"**Results:**\n\n{formatted}"
            else:
                formatted = "\n".join([f"{i+1}. {item}" for i, item in enumerate(result[:20])])
                return f"**Results (showing 20 of {len(result)}):**\n\n{formatted}"
        
        else:
            # Generic fallback
            return f"**Result:** {str(result)}"
    
    def process_query(self, llm_response: str, df: pd.DataFrame, query: str) -> str:
        """Complete pipeline: extract → validate → execute → format"""
        
        # Step 1: Extract code
        code = self.extract_code(llm_response)
        
        # Step 2: Validate
        is_valid, validation_msg = self.validate_code(code, df)
        
        if not is_valid:
            return f"Validation error: {validation_msg}"
        
        # Step 3: Execute
        success, result = self.execute_code(code, df)
        
        if not success:
            return f"Execution error: {result}"
        
        # Step 4: Format
        formatted = self.format_result(result, query)
        
        return formatted
